<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Planner Pro Ultimate</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#6366f1',
                        secondary: '#ec4899',
                        dark: '#0f172a',
                    },
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    }
                }
            }
        }
    </script>
    
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">

    <!-- Babel -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Google API Scripts -->
    <script src="https://apis.google.com/js/api.js"></script>
    <script src="https://accounts.google.com/gsi/client" async defer></script>
    
    <!-- Microsoft Auth Script (MSAL) -->
    <script src="https://alcdn.msauth.net/browser/2.30.0/js/msal-browser.min.js"></script>

    <!-- Import Map -->
    <script type="importmap">
    {
        "imports": {
            "react": "https://esm.sh/react@18.3.1",
            "react-dom/client": "https://esm.sh/react-dom@18.3.1/client",
            "framer-motion": "https://esm.sh/framer-motion@10.16.4?external=react,react-dom",
            "lucide-react": "https://esm.sh/lucide-react@0.292.0?external=react,react-dom",
            "date-fns": "https://esm.sh/date-fns@2.30.0"
        }
    }
    </script>

    <style>
        body { font-family: 'Inter', sans-serif; overflow: hidden; }
        .custom-scrollbar::-webkit-scrollbar { width: 6px; }
        .custom-scrollbar::-webkit-scrollbar-track { background: transparent; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background-color: #cbd5e1; border-radius: 20px; }
        
        .resize-handle {
            position: absolute;
            bottom: 0; left: 0; right: 0; height: 8px; cursor: ns-resize;
            background: transparent;
        }
        .resize-handle:hover { background: rgba(0,0,0,0.1); }
    </style>
</head>
<body class="bg-slate-100 text-slate-800 h-screen w-screen overflow-hidden">
    <div id="root" class="h-full w-full"></div>

    <script type="text/babel" data-type="module">
        import React, { useState, useEffect, useRef, useMemo, useCallback } from 'react';
        import { createRoot } from 'react-dom/client';
        import { 
            Check, Plus, Calendar as CalendarIcon, Clock, MoreHorizontal, Settings, 
            Zap, MessageSquare, ArrowRight, ChevronLeft, ChevronRight, Layout, 
            X, Moon, Trash2, Edit2, GripVertical, RefreshCw, Star, AlertCircle, 
            Globe, MapPin, User, Flag, Link as LinkIcon, Watch, Key, Mail, Sun
        } from 'lucide-react';
        import { motion, AnimatePresence } from 'framer-motion';
        import { 
            format, addDays, subDays, addMonths, subMonths, startOfWeek, endOfWeek, 
            eachDayOfInterval, isSameDay, addHours, startOfMonth, endOfMonth, 
            getDay, isToday, isSameMonth, differenceInMinutes, setHours, setMinutes,
            startOfDay, isPast, isBefore, addMinutes
        } from 'date-fns';

        // --- CONFIGURATION CONSTANTS ---
        const GOOGLE_DISCOVERY_DOC = 'https://www.googleapis.com/discovery/v1/apis/calendar/v3/rest';
        const GOOGLE_SCOPES = 'https://www.googleapis.com/auth/calendar.readonly';
        const MS_GRAPH_SCOPES = ['User.Read', 'Calendars.Read'];

        // --- Utils & Hooks ---

        function useLocalStorage(key, initialValue) {
            const [storedValue, setStoredValue] = useState(() => {
                try {
                    const item = window.localStorage.getItem(key);
                    const parsed = item ? JSON.parse(item) : initialValue;
                    if (Array.isArray(parsed) && key.includes('tasks')) {
                        return parsed.map(i => ({
                            ...i,
                            scheduledFor: i.scheduledFor ? new Date(i.scheduledFor) : null,
                            createdAt: i.createdAt ? new Date(i.createdAt) : new Date()
                        }));
                    }
                    if (Array.isArray(parsed) && key.includes('events')) {
                         return parsed.map(i => ({
                            ...i,
                            start: i.start ? new Date(i.start) : undefined,
                            end: i.end ? new Date(i.end) : undefined
                        }));
                    }
                    return parsed;
                } catch (error) { console.error(error); return initialValue; }
            });

            const setValue = (value) => {
                try {
                    const valueToStore = value instanceof Function ? value(storedValue) : value;
                    setStoredValue(valueToStore);
                    window.localStorage.setItem(key, JSON.stringify(valueToStore));
                } catch (error) { console.error(error); }
            };
            return [storedValue, setValue];
        }

        // Helper to parse YYYY-MM-DD as local time to avoid timezone shifts
        const parseLocalDate = (dateStr) => {
            if (!dateStr) return new Date();
            const parts = dateStr.split('-');
            // Note: Month is 0-indexed in JS Date
            return new Date(parts[0], parts[1] - 1, parts[2]);
        };

        // --- Datamuse API Helper ---
        const fetchSuggestions = async (query) => {
            if (!query || query.length < 2) return [];
            try {
                const res = await fetch(`https://api.datamuse.com/sug?s=${query}&max=5`);
                const data = await res.json();
                return data.map(item => item.word);
            } catch (e) { console.error(e); return []; }
        };

        const debounce = (func, wait) => {
            let timeout;
            return function(...args) {
                const context = this;
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(context, args), wait);
            };
        };

        const COUNTRIES = {
            US: { name: "United States", icon: "ðŸ‡ºðŸ‡¸" },
            KR: { name: "South Korea", icon: "ðŸ‡°ðŸ‡·" },
            CA: { name: "Canada", icon: "ðŸ‡¨ðŸ‡¦" },
            UK: { name: "United Kingdom", icon: "ðŸ‡¬ðŸ‡§" },
            JP: { name: "Japan", icon: "ðŸ‡¯ðŸ‡µ" },
            AU: { name: "Australia", icon: "ðŸ‡¦ðŸ‡º" },
            FR: { name: "France", icon: "ðŸ‡«ðŸ‡·" },
            DE: { name: "Germany", icon: "ðŸ‡©ðŸ‡ª" }
        };

        const TIMEZONES = [
            { label: 'Local', zone: Intl.DateTimeFormat().resolvedOptions().timeZone },
            { label: 'New York', zone: 'America/New_York' },
            { label: 'London', zone: 'Europe/London' },
            { label: 'Seoul', zone: 'Asia/Seoul' },
            { label: 'Tokyo', zone: 'Asia/Tokyo' },
            { label: 'Paris', zone: 'Europe/Paris' },
            { label: 'Berlin', zone: 'Europe/Berlin' },
            { label: 'Sydney', zone: 'Australia/Sydney' },
        ];

        const HOLIDAYS_DB = {
            US: { fixed: { "0-1": "New Year's", "6-4": "Independence Day", "10-11": "Veterans Day", "11-25": "Christmas" } },
            KR: { fixed: { "0-1": "New Year's", "2-1": "Indep. Move.", "4-5": "Children's Day", "7-15": "Liberation Day", "9-3": "Foundation Day", "9-9": "Hangeul Day", "11-25": "Christmas" } },
            // Add simplified others for brevity...
            UK: { fixed: { "0-1": "New Year's", "11-25": "Christmas" } },
            JP: { fixed: { "0-1": "New Year's" } },
            CA: { fixed: { "0-1": "New Year's", "6-1": "Canada Day" } }
        };

        const getHolidaysForDate = (date, selectedCountries) => {
            const m = date.getMonth();
            const d = date.getDate();
            const key = `${m}-${d}`;
            const results = [];
            selectedCountries.forEach(code => {
                const data = HOLIDAYS_DB[code];
                if (data && data.fixed && data.fixed[key]) results.push({ name: data.fixed[key], country: code });
            });
            return results;
        };

        const generateId = () => Math.random().toString(36).substr(2, 9);

        // --- Custom Components ---

        const TagInput = ({ value, onChange, placeholder, className, wordCounts }) => {
            const [inputValue, setInputValue] = useState('');
            const [suggestions, setSuggestions] = useState([]);
            const tags = value ? value.split(',').filter(t => t.trim()) : [];

            const getSuggestions = useCallback(debounce(async (query) => {
                if (!query) return;
                const localMatches = Object.keys(wordCounts).filter(w => w.toLowerCase().startsWith(query.toLowerCase()) && w.toLowerCase() !== query.toLowerCase());
                let remoteMatches = [];
                if (localMatches.length < 5) remoteMatches = await fetchSuggestions(query);
                setSuggestions([...new Set([...localMatches, ...remoteMatches])].slice(0, 5));
            }, 300), [wordCounts]);

            const handleKeyDown = (e) => {
                if (e.key === ',' || e.key === 'Enter') {
                    e.preventDefault();
                    if (inputValue.trim()) {
                        const newTags = [...tags, inputValue.trim()];
                        onChange({ target: { value: newTags.join(',') } });
                        setInputValue('');
                        setSuggestions([]);
                    }
                } else if (e.key === 'Backspace' && !inputValue && tags.length > 0) {
                    onChange({ target: { value: tags.slice(0, -1).join(',') } });
                }
            };

            return (
                <div className={`flex flex-wrap gap-2 p-2 border rounded-lg bg-white focus-within:ring-2 ring-indigo-500/20 ${className}`}>
                    {tags.map((tag, i) => (
                        <span key={i} onClick={() => { const n = tags.filter(t => t !== tag); onChange({ target: { value: n.join(',') } }); }} className="bg-indigo-100 text-indigo-700 px-2 py-1 rounded-md text-xs font-medium cursor-pointer hover:bg-indigo-200 flex items-center gap-1">
                            {tag} <X size={10} />
                        </span>
                    ))}
                    <div className="relative flex-1 min-w-[60px]">
                        <input type="text" value={inputValue} onChange={(e) => { setInputValue(e.target.value); getSuggestions(e.target.value); }} onKeyDown={handleKeyDown} placeholder={tags.length === 0 ? placeholder : ''} className="w-full outline-none text-sm bg-transparent" />
                        {suggestions.length > 0 && (
                            <ul className="absolute left-0 top-full mt-1 bg-white border border-slate-200 rounded-lg shadow-xl z-50 w-48 text-sm">
                                {suggestions.map(s => (<li key={s} onClick={() => { onChange({ target: { value: [...tags, s].join(',') } }); setInputValue(''); setSuggestions([]); }} className="px-3 py-2 hover:bg-indigo-50 cursor-pointer text-slate-700">{s}</li>))}
                            </ul>
                        )}
                    </div>
                </div>
            );
        };

        const AutocompleteInput = ({ value, onChange, wordCounts, placeholder, className, autoFocus }) => {
            const [suggestions, setSuggestions] = useState([]);
            const [showSuggestions, setShowSuggestions] = useState(false);
            
            const getRemoteSuggestions = useCallback(debounce(async (word) => {
                const results = await fetchSuggestions(word);
                setSuggestions(prev => [...new Set([...prev, ...results])].slice(0, 5));
            }, 300), []);

            const handleChange = (e) => {
                const val = e.target.value;
                onChange(e);
                const match = val.match(/(\S+)$/);
                if (match && match[1].length >= 2) {
                    const word = match[1];
                    const local = Object.keys(wordCounts).filter(w => w.toLowerCase().startsWith(word.toLowerCase()) && w.toLowerCase() !== word.toLowerCase());
                    setSuggestions(local.slice(0,5));
                    setShowSuggestions(true);
                    getRemoteSuggestions(word);
                } else {
                    setShowSuggestions(false);
                }
            };

            const handleSelect = (s) => {
                const match = value.match(/(\S+)$/);
                if (match) {
                    const newVal = value.substring(0, match.index) + s + ' ';
                    onChange({ target: { value: newVal } });
                    setShowSuggestions(false);
                }
            };

            return (
                <div className="relative w-full">
                    <input type="text" value={value} onChange={handleChange} onBlur={() => setTimeout(() => setShowSuggestions(false), 200)} placeholder={placeholder} className={className} autoFocus={autoFocus} />
                    {showSuggestions && suggestions.length > 0 && (
                        <ul className="absolute left-0 right-0 top-full mt-1 bg-white border border-slate-200 rounded-lg shadow-xl z-50 text-sm">
                            {suggestions.map(s => (<li key={s} onClick={() => handleSelect(s)} className="px-3 py-2 hover:bg-indigo-50 cursor-pointer flex justify-between"><span>{s}</span><span className="text-[10px] text-slate-400">Tab</span></li>))}
                        </ul>
                    )}
                </div>
            );
        };

        // --- Modals ---

        const Modal = ({ isOpen, onClose, title, children }) => {
            if (!isOpen) return null;
            return (
                <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/20 backdrop-blur-sm p-4">
                    <motion.div initial={{ opacity: 0, scale: 0.95 }} animate={{ opacity: 1, scale: 1 }} className="bg-white rounded-2xl shadow-xl w-full max-w-md flex flex-col max-h-[90vh]">
                        <div className="flex justify-between items-center p-4 border-b border-slate-100">
                            <h3 className="text-lg font-bold text-slate-800">{title}</h3>
                            <button onClick={onClose} className="p-1 hover:bg-slate-100 rounded-full text-slate-400 hover:text-slate-600"><X size={20} /></button>
                        </div>
                        <div className="p-4 overflow-y-auto custom-scrollbar">{children}</div>
                    </motion.div>
                </div>
            );
        };

        const SettingsModal = ({ isOpen, onClose, selectedCountries, onToggleCountry, googleConnected, onToggleGoogle, googleConfig, onUpdateGoogleConfig, microsoftConnected, onToggleMicrosoft, microsoftConfig, onUpdateMicrosoftConfig }) => {
            return (
                <Modal isOpen={isOpen} onClose={onClose} title="Settings">
                    <div className="space-y-6">
                        <div>
                            <h4 className="text-sm font-bold text-slate-900 mb-3 flex items-center gap-2"><Key size={16} /> API Credentials</h4>
                            <div className="bg-slate-50 p-3 rounded-xl border border-slate-200 space-y-4">
                                <div className="space-y-2">
                                    <h5 className="text-xs font-bold text-blue-600">Google Calendar</h5>
                                    <input type="text" value={googleConfig.clientId} onChange={(e) => onUpdateGoogleConfig('clientId', e.target.value)} placeholder="Google Client ID" className="w-full text-xs p-2 border rounded-lg" />
                                    <input type="password" value={googleConfig.apiKey} onChange={(e) => onUpdateGoogleConfig('apiKey', e.target.value)} placeholder="Google API Key" className="w-full text-xs p-2 border rounded-lg" />
                                </div>
                                <div className="border-t border-slate-200"></div>
                                <div className="space-y-2">
                                    <h5 className="text-xs font-bold text-purple-600">Microsoft Outlook / Teams</h5>
                                    <input type="text" value={microsoftConfig.clientId} onChange={(e) => onUpdateMicrosoftConfig('clientId', e.target.value)} placeholder="Application (Client) ID" className="w-full text-xs p-2 border rounded-lg" />
                                </div>
                            </div>
                        </div>
                        <div>
                            <h4 className="text-sm font-bold text-slate-900 mb-3 flex items-center gap-2"><CalendarIcon size={16} /> Integrations</h4>
                            <div className="space-y-2">
                                <div className="flex items-center justify-between p-3 rounded-xl border border-slate-200 bg-white">
                                    <div className="flex items-center gap-3"><div className="w-8 h-8 rounded-full bg-blue-100 flex items-center justify-center text-blue-600 font-bold">G</div><div className="text-sm font-medium text-slate-900">Google Calendar</div></div>
                                    <button onClick={onToggleGoogle} className={`px-3 py-1.5 rounded-lg text-xs font-bold transition-colors ${googleConnected ? 'bg-red-50 text-red-600 border border-red-200' : 'bg-blue-600 text-white hover:bg-blue-700'}`}>{googleConnected ? 'Disconnect' : 'Connect'}</button>
                                </div>
                                <div className="flex items-center justify-between p-3 rounded-xl border border-slate-200 bg-white">
                                    <div className="flex items-center gap-3"><div className="w-8 h-8 rounded-full bg-purple-100 flex items-center justify-center text-purple-600 font-bold">M</div><div className="text-sm font-medium text-slate-900">Outlook / Teams</div></div>
                                    <button onClick={onToggleMicrosoft} className={`px-3 py-1.5 rounded-lg text-xs font-bold transition-colors ${microsoftConnected ? 'bg-red-50 text-red-600 border border-red-200' : 'bg-purple-600 text-white hover:bg-purple-700'}`}>{microsoftConnected ? 'Disconnect' : 'Connect'}</button>
                                </div>
                            </div>
                        </div>
                    </div>
                </Modal>
            );
        };
        // End of Part 1. Type "go" for the next part.
        const WeekView = ({ currentDate, events, tasks, selectedCountries, onDropTask, onSlotClick, onUpdateEvent }) => {
            const days = eachDayOfInterval({ start: startOfWeek(currentDate), end: endOfWeek(currentDate) });
            const hours = Array.from({ length: 24 }, (_, i) => i);
            const PIXELS_PER_HOUR = 60;
            const SNAP_MINUTES = 15;
            
            // Auto-scroll to 8 AM on mount
            useEffect(() => {
                const scrollContainer = document.getElementById('week-view-scroll');
                if (scrollContainer) {
                    scrollContainer.scrollTop = 480;
                }
            }, []);
            
            // --- Layout Engine for Side-by-Side Events ---
            const calculateEventLayout = (dayEvents) => {
                // Filter out all-day events, they go in the top row
                const timedEvents = dayEvents.filter(e => !e.isAllDay);
                
                // Sort by start time, then duration
                const sortedEvents = [...timedEvents].sort((a, b) => a.start - b.start || (b.end - b.start) - (a.end - a.start));
                const lanes = [];

                // Simple greedy algorithm to pack events into columns
                sortedEvents.forEach(event => {
                    let placed = false;
                    for (let i = 0; i < lanes.length; i++) {
                        const lane = lanes[i];
                        const lastEventInLane = lane[lane.length - 1];
                        // If no overlap with the last event in this lane
                        if (!lastEventInLane || lastEventInLane.end <= event.start) {
                            lane.push(event);
                            event.laneIndex = i;
                            placed = true;
                            break;
                        }
                    }
                    // If it overlaps with all existing lanes, create a new one
                    if (!placed) {
                        lanes.push([event]);
                        event.laneIndex = lanes.length - 1;
                    }
                });

                return { sortedEvents, laneCount: lanes.length };
            };

            const handleDrop = (e, day) => {
                e.preventDefault();
                const rect = e.currentTarget.getBoundingClientRect();
                const offsetY = e.clientY - rect.top + e.currentTarget.scrollTop;
                const rawMinutes = offsetY * (60 / PIXELS_PER_HOUR); 
                const snappedMinutes = Math.floor(rawMinutes / SNAP_MINUTES) * SNAP_MINUTES;
                const hour = Math.floor(snappedMinutes / 60);
                const minutes = snappedMinutes % 60;

                const taskId = e.dataTransfer.getData('taskId');
                const eventId = e.dataTransfer.getData('eventId');

                if (taskId) {
                    onDropTask(taskId, day, hour, minutes);
                } else if (eventId) {
                    const event = events.find(e => e.id === eventId);
                    if (event && !event.isAllDay) {
                        const duration = differenceInMinutes(new Date(event.end), new Date(event.start));
                        const newStart = setMinutes(setHours(new Date(day), hour), minutes);
                        const newEnd = addDays(newStart, 0);
                        newEnd.setMinutes(newStart.getMinutes() + duration);
                        onUpdateEvent({ ...event, start: newStart, end: newEnd });
                    }
                }
            };

            const handleResizeStart = (e, event) => {
                e.stopPropagation(); 
                e.preventDefault();
                const startY = e.clientY;
                const originalEnd = new Date(event.end);
                
                const handleMouseMove = (moveEvent) => {
                    const deltaY = moveEvent.clientY - startY;
                    const deltaMinutes = (deltaY / PIXELS_PER_HOUR) * 60;
                    const snappedDelta = Math.round(deltaMinutes / SNAP_MINUTES) * SNAP_MINUTES;
                    if (snappedDelta !== 0) {
                        const newEnd = new Date(originalEnd);
                        newEnd.setMinutes(originalEnd.getMinutes() + snappedDelta);
                        // Minimum 15 mins
                        if (differenceInMinutes(newEnd, new Date(event.start)) >= 15) {
                            onUpdateEvent({ ...event, end: newEnd });
                        }
                    }
                };
                
                const handleMouseUp = () => {
                    window.removeEventListener('mousemove', handleMouseMove);
                    window.removeEventListener('mouseup', handleMouseUp);
                };
                
                window.addEventListener('mousemove', handleMouseMove);
                window.addEventListener('mouseup', handleMouseUp);
            };

            const handleSlotClickInternal = (e, day, hour) => {
                const rect = e.currentTarget.getBoundingClientRect();
                const offsetY = e.clientY - rect.top; 
                const minutes = offsetY > (PIXELS_PER_HOUR / 2) ? 30 : 0;
                onSlotClick(day, hour, null, minutes);
            };

            return (
                <div className="flex flex-col h-full bg-white rounded-xl border border-slate-200 shadow-sm overflow-hidden">
                    {/* 1. Date Headers */}
                    <div className="flex border-b border-slate-200 ml-16">
                        {days.map(day => {
                            const isSun = getDay(day) === 0;
                            return (
                                <div key={day.toString()} className={`flex-1 py-3 text-center border-r border-slate-100 last:border-0 ${isSun ? 'bg-red-50/20' : ''}`}>
                                    <div className={`text-xs font-bold uppercase ${isSun ? 'text-red-500' : 'text-slate-500'}`}>{format(day, 'EEE')}</div>
                                    <div className={`text-sm font-bold mt-1 inline-block w-8 h-8 leading-8 rounded-full ${isToday(day) ? 'bg-indigo-600 text-white shadow-md' : isSun ? 'text-red-600' : 'text-slate-700'}`}>{format(day, 'd')}</div>
                                </div>
                            );
                        })}
                    </div>

                    {/* 2. All-Day Section (Separate Row) */}
                    <div className="flex border-b border-slate-200 bg-slate-50 min-h-[40px] ml-16">
                         {days.map(day => {
                            const allDayEvents = events.filter(e => isSameDay(new Date(e.start), day) && e.isAllDay);
                            const holidays = getHolidaysForDate(day, selectedCountries);
                            
                            return (
                                <div key={'allday-'+day} className="flex-1 border-r border-slate-200 p-1 flex flex-col gap-1">
                                    {/* Holidays */}
                                    {holidays.map((h, i) => (
                                        <div key={'h'+i} className="text-[9px] font-bold text-slate-500 text-center bg-white border border-slate-200 rounded px-1 truncate select-none">
                                            {h.name}
                                        </div>
                                    ))}
                                    {/* All Day Tasks */}
                                    {allDayEvents.map(ev => (
                                        <div 
                                            key={ev.id} 
                                            onClick={(e) => { e.stopPropagation(); onSlotClick(null, null, ev); }}
                                            className={`text-[10px] font-medium px-1 py-0.5 rounded truncate border cursor-pointer hover:opacity-80 ${ev.color || 'bg-yellow-100 text-yellow-800 border-yellow-200'}`}
                                        >
                                            {ev.title}
                                        </div>
                                    ))}
                                </div>
                            );
                         })}
                    </div>

                    {/* 3. Main Timeline Grid */}
                    <div id="week-view-scroll" className="flex-1 overflow-y-auto custom-scrollbar relative flex">
                        {/* Time Labels */}
                        <div className="w-16 flex-shrink-0 bg-slate-50 border-r border-slate-200 text-xs text-slate-400 font-medium">
                            {hours.map(hour => (
                                <div key={hour} className="relative border-b border-transparent" style={{ height: `${PIXELS_PER_HOUR}px` }}>
                                    <span className="absolute -top-3 right-3">{format(setHours(new Date(), hour), 'h a')}</span>
                                </div>
                            ))}
                        </div>

                        {/* Days Columns */}
                        {days.map(day => {
                            // Filter only timed events for the grid
                            const dayEvents = events.filter(e => isSameDay(new Date(e.start), day));
                            const { sortedEvents, laneCount } = calculateEventLayout(dayEvents);
                            const isSun = getDay(day) === 0;
                            
                            return (
                                <div 
                                    key={day.toString()}
                                    onDragOver={e => e.preventDefault()}
                                    onDrop={(e) => handleDrop(e, day)}
                                    className={`flex-1 relative border-r border-slate-100 last:border-0 hover:bg-slate-50 ${isSun ? 'bg-red-50/5' : ''}`}
                                    style={{ height: `${24 * PIXELS_PER_HOUR}px` }}
                                >
                                    {/* Hour Grid Lines */}
                                    {hours.map(h => (
                                        <div 
                                            key={h} 
                                            onClick={(e) => handleSlotClickInternal(e, day, h)}
                                            className="border-b border-slate-100 w-full absolute cursor-pointer hover:bg-indigo-50/30" 
                                            style={{ top: `${h * PIXELS_PER_HOUR}px`, height: `${PIXELS_PER_HOUR}px` }}
                                        ></div>
                                    ))}

                                    {/* Render Timed Events */}
                                    {sortedEvents.map(event => {
                                        const startMin = event.start.getHours() * 60 + event.start.getMinutes();
                                        const duration = differenceInMinutes(new Date(event.end), new Date(event.start));
                                        const linkedTask = tasks.find(t => t.id === event.taskId);
                                        const isDone = linkedTask?.completed;
                                        
                                        // Layout Calculations
                                        const widthPercent = 100 / (laneCount || 1);
                                        const leftPercent = (event.laneIndex || 0) * widthPercent;

                                        return (
                                            <div
                                                key={event.id}
                                                draggable
                                                onDragStart={(e) => { e.dataTransfer.setData('eventId', event.id); }}
                                                onClick={(e) => { e.stopPropagation(); onSlotClick(null, null, event); }}
                                                className={`absolute rounded-md text-xs border shadow-sm z-10 overflow-hidden cursor-pointer hover:shadow-md transition-all select-none
                                                    ${isDone ? 'bg-slate-200 border-slate-300 text-slate-400 line-through' : (event.color || 'bg-blue-100 border-blue-200 text-blue-700')}
                                                `}
                                                style={{
                                                    top: `${startMin * (PIXELS_PER_HOUR / 60)}px`,
                                                    height: `${Math.max(duration * (PIXELS_PER_HOUR / 60), 15)}px`,
                                                    left: `${leftPercent}%`,
                                                    width: `${widthPercent}%`,
                                                    zIndex: 10 + (event.laneIndex || 0) // Ensure stacking order
                                                }}
                                            >
                                                <div className="px-1 py-0.5 font-semibold truncate leading-tight pointer-events-none">{event.title}</div>
                                                <div className="px-1 text-[9px] opacity-75 pointer-events-none">{format(new Date(event.start), 'h:mm a')} - {format(new Date(event.end), 'h:mm a')}</div>
                                                <div className="resize-handle" onMouseDown={(e) => handleResizeStart(e, event)}></div>
                                            </div>
                                        );
                                    })}
                                </div>
                            );
                        })}
                    </div>
                </div>
            );
        };

        // --- Main App Logic ---

        function App() {
            // --- State ---
            const [tasks, setTasks] = useLocalStorage('ai-planner-tasks', []);
            const [events, setEvents] = useLocalStorage('ai-planner-events', []);
            const [selectedCountries, setSelectedCountries] = useLocalStorage('ai-planner-countries', ['US']);
            const [clocks, setClocks] = useLocalStorage('ai-planner-clocks', [{ id: 'local', label: 'Local', zone: Intl.DateTimeFormat().resolvedOptions().timeZone }]);
            const [wordCounts, setWordCounts] = useLocalStorage('ai-planner-word-freq', {'Meeting': 10, 'Call': 8});
            
            // Auth Configs
            const [googleConfig, setGoogleConfig] = useLocalStorage('ai-planner-google-config', { clientId: '', apiKey: '' });
            const [microsoftConfig, setMicrosoftConfig] = useLocalStorage('ai-planner-microsoft-config', { clientId: '' });

            // UI State
            const [viewMode, setViewMode] = useState('week');
            const [currentDate, setCurrentDate] = useState(new Date());
            const [inputValue, setInputValue] = useState('');
            const [isEditModalOpen, setIsEditModalOpen] = useState(false);
            const [isSettingsOpen, setIsSettingsOpen] = useState(false);
            const [isClockModalOpen, setIsClockModalOpen] = useState(false);
            const [activeItem, setActiveItem] = useState(null); 
            const [aiMessage, setAiMessage] = useState("Ready to plan! Drag tasks to the schedule.");
            const [overdueTask, setOverdueTask] = useState(null);
            const [selectedCategory, setSelectedCategory] = useState('medium');
            
            // Connection Status
            const [googleConnected, setGoogleConnected] = useState(false);
            const [microsoftConnected, setMicrosoftConnected] = useState(false);
            
            const tokenClient = useRef(null);
            const msalInstance = useRef(null);

            // --- Helper Functions ---
            const updateWordFreq = (text) => {
                if (!text) return;
                const words = text.split(/[\s,.]+/);
                const updates = { ...wordCounts };
                words.forEach(w => { const clean = w.trim(); if (clean.length > 2) updates[clean] = (updates[clean] || 0) + 1; });
                setWordCounts(updates);
            };

            // --- Google Calendar Init & Sync ---
            const initGoogleAPI = () => {
                if (typeof window.google === 'undefined' || typeof window.gapi === 'undefined') return;
                if (!googleConfig.clientId || !googleConfig.apiKey) return;

                const gapi = window.gapi;
                const google = window.google;

                gapi.load('client', async () => {
                    try {
                        await gapi.client.init({ apiKey: googleConfig.apiKey, discoveryDocs: [GOOGLE_DISCOVERY_DOC] });
                        if (!gapi.client.calendar) await gapi.client.load('calendar', 'v3');
                    } catch (e) {
                        console.error("GAPI Init Error", e);
                        if (e.result?.error?.code === 403) setAiMessage("Error 403: Enable Google Calendar API in Cloud Console.");
                    }
                });

                tokenClient.current = google.accounts.oauth2.initTokenClient({
                    client_id: googleConfig.clientId,
                    scope: GOOGLE_SCOPES,
                    callback: async (resp) => {
                        if (resp.error) { setAiMessage("Google Auth Error: " + resp.error.message); return; }
                        if (window.gapi) window.gapi.client.setToken(resp);
                        setGoogleConnected(true);
                        await listGoogleEvents();
                    },
                });
            };

            // --- Microsoft Graph Init & Sync ---
            const initMicrosoftAPI = () => {
                if (!window.msal || !microsoftConfig.clientId) return;
                
                const msalConfig = {
                    auth: {
                        clientId: microsoftConfig.clientId,
                        redirectUri: window.location.href.split('?')[0],
                    },
                    cache: { cacheLocation: "sessionStorage" }
                };
                
                msalInstance.current = new window.msal.PublicClientApplication(msalConfig);
                msalInstance.current.initialize().then(() => {
                   const accounts = msalInstance.current.getAllAccounts();
                   if (accounts.length > 0) {
                       msalInstance.current.setActiveAccount(accounts[0]);
                       setMicrosoftConnected(true);
                       listMicrosoftEvents();
                   }
                }).catch(e => console.error("MSAL Init Error", e));
            };

            useEffect(() => { initGoogleAPI(); }, [googleConfig]);
            useEffect(() => { initMicrosoftAPI(); }, [microsoftConfig]);

            const listGoogleEvents = async () => {
                if (typeof window.gapi === 'undefined' || !window.gapi.client || !window.gapi.client.calendar) return;
                try {
                    const startRange = new Date(); startRange.setDate(startRange.getDate() - 30);
                    const request = { 'calendarId': 'primary', 'timeMin': startRange.toISOString(), 'showDeleted': false, 'singleEvents': true, 'maxResults': 100, 'orderBy': 'startTime' };
                    const response = await window.gapi.client.calendar.events.list(request);
                    
                    const realEvents = response.result.items.map(item => {
                        // Check if it's all day (date only, no dateTime)
                        const isAllDay = !item.start.dateTime;
                        return {
                            id: item.id,
                            title: item.summary,
                            isAllDay: isAllDay,
                            // If all day, use parseLocalDate to avoid timezone shifts. If timed, use standard Date constructor
                            start: isAllDay ? parseLocalDate(item.start.date) : new Date(item.start.dateTime),
                            end: isAllDay ? parseLocalDate(item.end.date) : new Date(item.end.dateTime),
                            color: 'bg-blue-50 border-blue-200 text-blue-700',
                            type: 'google'
                        };
                    });
                    
                    setEvents(prev => {
                        // Remove old google events
                        const others = prev.filter(e => e.type !== 'google');
                        return [...others, ...realEvents];
                    });
                    setAiMessage(`Synced ${realEvents.length} Google events.`);
                } catch (err) { console.error(err); setAiMessage("Google Sync Failed."); }
            };

            const listMicrosoftEvents = async () => {
                if (!msalInstance.current) return;
                try {
                    const response = await msalInstance.current.acquireTokenSilent({ scopes: MS_GRAPH_SCOPES });
                    const headers = new Headers();
                    headers.append("Authorization", `Bearer ${response.accessToken}`);
                    headers.append("Prefer", 'outlook.timezone="UTC"'); 

                    const start = new Date(); start.setDate(start.getDate() - 30);
                    const end = new Date(); end.setDate(end.getDate() + 90);
                    const url = `https://graph.microsoft.com/v1.0/me/calendarview?startDateTime=${start.toISOString()}&endDateTime=${end.toISOString()}`;
                    
                    const graphRes = await fetch(url, { method: "GET", headers: headers });
                    const data = await graphRes.json();
                    
                    if (data.value) {
                        const msEvents = data.value.map(ev => {
                            const isAllDay = ev.isAllDay;
                            // For MS Graph UTC, All Day events usually come as YYYY-MM-DDT00:00:00Z
                            // We treat them as local date strings to avoid shift
                            return {
                                id: ev.id,
                                title: ev.subject,
                                isAllDay: isAllDay,
                                start: isAllDay ? parseLocalDate(ev.start.dateTime.split('T')[0]) : new Date(ev.start.dateTime + 'Z'),
                                end: isAllDay ? parseLocalDate(ev.end.dateTime.split('T')[0]) : new Date(ev.end.dateTime + 'Z'),
                                color: 'bg-purple-50 border-purple-200 text-purple-700',
                                type: 'microsoft'
                            };
                        });
                        
                        setEvents(prev => {
                             const others = prev.filter(e => e.type !== 'microsoft');
                             return [...others, ...msEvents];
                        });
                        setAiMessage(`Synced ${msEvents.length} Microsoft events.`);
                    }
                } catch (e) {
                    if (e instanceof window.msal.InteractionRequiredAuthError) {
                        msalInstance.current.acquireTokenPopup({ scopes: MS_GRAPH_SCOPES }).then(listMicrosoftEvents);
                    }
                }
            };

            // --- Manual Toggles ---
            const handleToggleGoogle = () => {
                if (!googleConfig.clientId) { setAiMessage("Setup Google Keys first."); return; }
                if (googleConnected) {
                    setGoogleConnected(false);
                    const token = window.gapi.client.getToken();
                    if (token) { window.google.accounts.oauth2.revoke(token.access_token, () => {}); window.gapi.client.setToken(''); }
                    setEvents(prev => prev.filter(e => e.type !== 'google'));
                } else {
                    if (tokenClient.current) tokenClient.current.requestAccessToken({ prompt: 'consent' });
                    else initGoogleAPI();
                }
            };

            const handleToggleMicrosoft = async () => {
                if (!microsoftConfig.clientId) { setAiMessage("Setup Microsoft ID first."); return; }
                if (!msalInstance.current) initMicrosoftAPI();
                
                if (microsoftConnected) {
                    const account = msalInstance.current.getActiveAccount();
                    if (account) await msalInstance.current.logoutPopup({ account });
                    setMicrosoftConnected(false);
                    setEvents(prev => prev.filter(e => e.type !== 'microsoft'));
                } else {
                    try {
                        await msalInstance.current.loginPopup({ scopes: MS_GRAPH_SCOPES });
                        const accounts = msalInstance.current.getAllAccounts();
                        if (accounts.length > 0) {
                            msalInstance.current.setActiveAccount(accounts[0]);
                            setMicrosoftConnected(true);
                            listMicrosoftEvents();
                        }
                    } catch(e) { console.error(e); }
                }
            };

            // --- Background Monitor ---
            useEffect(() => {
                const checkStatus = () => {
                    const now = new Date();
                    const missed = events.find(e => {
                        const task = tasks.find(t => t.id === e.taskId);
                        if (!task || task.completed) return false;
                        return isBefore(new Date(e.end), now);
                    });
                    if (missed) { const task = tasks.find(t => t.id === missed.taskId); setOverdueTask({ event: missed, task }); }
                };
                
                const syncAll = () => {
                    if (googleConnected) listGoogleEvents();
                    if (microsoftConnected) listMicrosoftEvents();
                };

                checkStatus();
                const interval = setInterval(() => { checkStatus(); syncAll(); }, 900000); 
                return () => clearInterval(interval);
            }, [events, tasks, googleConnected, microsoftConnected]);

            // --- Interaction Handlers ---
            const handleOverdueAction = (action) => {
                if (!overdueTask) return;
                if (action === 'finish') { setTasks(prev => prev.map(t => t.id === overdueTask.task.id ? { ...t, completed: true } : t)); setOverdueTask(null); setAiMessage("Task marked complete!"); }
                else if (action === 'reschedule') {
                    let cursor = new Date(); if (cursor.getHours() < 9) cursor.setHours(9, 0, 0, 0); else cursor = addHours(cursor, 1); 
                    for (let i = 0; i < 50; i++) {
                        const slotEnd = addHours(cursor, 1);
                        const busy = events.some(e => !e.isAllDay && (new Date(e.start) < slotEnd && new Date(e.end) > cursor) && e.id !== overdueTask.event.id);
                        if (!busy && cursor.getHours() >= 9 && cursor.getHours() <= 17) {
                            const updatedEvent = { ...overdueTask.event, start: cursor, end: slotEnd };
                            setEvents(prev => prev.map(e => e.id === overdueTask.event.id ? updatedEvent : e));
                            setOverdueTask(null);
                            setAiMessage(`Rescheduled to ${format(cursor, 'EEE h:mm a')}`);
                            return;
                        }
                        cursor = addHours(cursor, 1);
                    }
                    setOverdueTask(null);
                }
            };

            const handleUpdateGoogleConfig = (f, v) => setGoogleConfig(p => ({ ...p, [f]: v }));
            const handleUpdateMicrosoftConfig = (f, v) => setMicrosoftConfig(p => ({ ...p, [f]: v }));
            const handleToggleCountry = (c) => setSelectedCountries(p => p.includes(c) ? p.filter(x => x !== c) : [...p, c]);
            const handleAddClock = (z) => { setClocks(p => [...p, { id: generateId(), label: z.label.split(' ')[0], zone: z.zone }]); setIsClockModalOpen(false); };
            const onDeleteClock = (id) => setClocks(p => p.filter(c => c.id !== id));
            const handleDateNav = (dir) => setCurrentDate(prev => viewMode === 'week' ? (dir === 'next' ? addDays(prev, 7) : subDays(prev, 7)) : (dir === 'next' ? addMonths(prev, 1) : subMonths(prev, 1)));
            const handleAddTask = (e) => { e.preventDefault(); if (!inputValue.trim()) return; updateWordFreq(inputValue); setTasks(prev => [{ id: generateId(), title: inputValue, completed: false, priority: selectedCategory, createdAt: new Date(), duration: 60, scheduledFor: null }, ...prev]); setInputValue(''); };
            
            const handleSaveItem = () => {
                if (!activeItem) return;
                updateWordFreq(activeItem.title); updateWordFreq(activeItem.location); updateWordFreq(activeItem.person);
                const taskPayload = { id: activeItem.taskId || activeItem.id, title: activeItem.title, completed: activeItem.completed || false, priority: activeItem.priority || 'medium', location: activeItem.location||'', person: activeItem.person||'', duration: activeItem.duration || 60 };
                setTasks(prev => { const ex = prev.some(t=>t.id===taskPayload.id); return ex ? prev.map(t=>t.id===taskPayload.id?taskPayload:t) : [...prev, taskPayload] });
                if (activeItem.start && activeItem.end) {
                     const eventPayload = { id: activeItem.eventId || generateId(), taskId: taskPayload.id, title: activeItem.title, start: activeItem.start, end: activeItem.end, color: activeItem.color || 'bg-blue-100 text-blue-800', location: activeItem.location, person: activeItem.person, isAllDay: activeItem.isAllDay };
                     setEvents(prev => { const ex = prev.some(e=>e.id===eventPayload.id); return ex ? prev.map(e=>e.id===eventPayload.id?eventPayload:e) : [...prev, eventPayload]; });
                }
                setIsEditModalOpen(false); setActiveItem(null);
            };
            const handleUpdateEvent = (ev) => setEvents(p => p.map(e => e.id === ev.id ? ev : e));
            const handleDelete = () => { 
                if (activeItem.taskId) { setTasks(p=>p.filter(t=>t.id!==activeItem.taskId)); setEvents(p=>p.filter(e=>e.taskId!==activeItem.taskId)); }
                else if (activeItem.id) { setTasks(p=>p.filter(t=>t.id!==activeItem.id)); setEvents(p=>p.filter(e=>e.id!==activeItem.id)); }
                setIsEditModalOpen(false); 
            };
            const handleDropTask = (taskId, day, hour, minutes) => {
                const task = tasks.find(t => t.id === taskId); if (!task) return;
                const start = setMinutes(setHours(new Date(day), hour), minutes);
                const end = addDays(start, 0); end.setMinutes(start.getMinutes() + (task.duration || 60));
                const newEvent = { id: generateId(), taskId: task.id, title: task.title, start, end, isAllDay: false, color: 'bg-indigo-100 text-indigo-800' };
                setEvents(prev => [...prev, newEvent]);
            };
            const openEditModal = (day, hour, existingItem=null, minutes=0) => {
                if (existingItem) {
                     if (existingItem.taskId) { const t = tasks.find(x=>x.id===existingItem.taskId); setActiveItem({ ...t, eventId: existingItem.id, start: existingItem.start, end: existingItem.end, isEvent: true, isAllDay: existingItem.isAllDay }); }
                     else if (existingItem.start) setActiveItem({ ...existingItem, isEvent: true });
                     else setActiveItem({ ...existingItem, isEvent: false });
                } else {
                    const start = new Date(day); start.setHours(hour||9, minutes, 0, 0);
                    const end = new Date(start); end.setMinutes(start.getMinutes() + 60);
                    setActiveItem({ id: generateId(), title: '', start, end, priority: 'medium', color: 'bg-blue-100 text-blue-800', isEvent: true, isAllDay: false });
                }
                setIsEditModalOpen(true);
            };

            return (
                <div className="flex flex-col md:flex-row h-full bg-slate-100 overflow-hidden">
                    {/* Left Side */}
                    <div className="flex-1 flex flex-col h-full overflow-hidden relative border-r border-slate-200">
                        <div className="bg-white border-b border-slate-200 p-4 flex items-center justify-between shadow-sm z-10">
                            <div className="flex items-center gap-4">
                                <div className="flex bg-slate-100 rounded-lg p-1">
                                    <button onClick={() => setViewMode('week')} className={`px-3 py-1.5 text-xs font-semibold rounded-md transition-all ${viewMode === 'week' ? 'bg-white text-indigo-600 shadow-sm' : 'text-slate-500'}`}>Weekly</button>
                                    <button onClick={() => setViewMode('month')} className={`px-3 py-1.5 text-xs font-semibold rounded-md transition-all ${viewMode === 'month' ? 'bg-white text-indigo-600 shadow-sm' : 'text-slate-500'}`}>Monthly</button>
                                </div>
                                <div className="flex items-center gap-2">
                                    <button onClick={() => handleDateNav('prev')} className="p-1.5 hover:bg-slate-100 rounded-full"><ChevronLeft size={20} /></button>
                                    <h2 className="text-lg font-bold text-slate-800 w-48 text-center select-none">{format(currentDate, 'MMMM yyyy')}</h2>
                                    <button onClick={() => handleDateNav('next')} className="p-1.5 hover:bg-slate-100 rounded-full"><ChevronRight size={20} /></button>
                                </div>
                            </div>
                            <div className="flex gap-2">
                                <button onClick={() => setCurrentDate(new Date())} className="text-sm font-medium text-indigo-600 hover:bg-indigo-50 px-3 py-1.5 rounded-lg">Today</button>
                                <button onClick={() => setIsSettingsOpen(true)} className="p-2 text-slate-400 hover:bg-slate-100 rounded-lg"><Settings size={20}/></button>
                            </div>
                        </div>
                        <div className="flex-1 p-4 overflow-hidden bg-slate-50">
                            {viewMode === 'week' ? (
                                <WeekView currentDate={currentDate} events={events} tasks={tasks} selectedCountries={selectedCountries} onDropTask={handleDropTask} onSlotClick={openEditModal} onUpdateEvent={handleUpdateEvent} />
                            ) : (
                                <MonthView currentDate={currentDate} events={events} selectedCountries={selectedCountries} onSlotClick={openEditModal} tasks={tasks} />
                            )}
                        </div>
                    </div>

                    {/* Right Side */}
                    <div className="w-full md:w-[380px] bg-white flex flex-col shadow-xl z-20 border-l border-slate-200">
                        <div className="bg-slate-900 pb-4">
                            <div className="p-6 pb-2"><h1 className="text-xl font-bold text-white flex items-center gap-2"><span className="bg-indigo-500 text-white p-1.5 rounded-lg"><Layout size={18}/></span>Planner Pro</h1></div>
                            <WorldClockBar clocks={clocks} onAddClock={() => setIsClockModalOpen(true)} onDeleteClock={(id) => setClocks(prev => prev.filter(c => c.id !== id))} />
                        </div>
                        <div className="p-6 pt-6 border-b border-slate-100">
                            <form onSubmit={handleAddTask} className="relative">
                                <AutocompleteInput value={inputValue} onChange={(e) => setInputValue(e.target.value)} placeholder="Add new task..." className="w-full pl-4 pr-10 py-3 bg-slate-50 border border-slate-200 rounded-xl focus:ring-2 focus:ring-indigo-500 text-sm" wordCounts={wordCounts} />
                                <button type="submit" className="absolute right-2 top-2 p-1.5 text-indigo-500 hover:bg-indigo-50 rounded-lg"><Plus size={18}/></button>
                                <div className="flex gap-2 mt-3">
                                    {['high', 'medium', 'low', 'personal'].map(p => (<button key={p} type="button" onClick={() => setSelectedCategory(p)} className={`text-[10px] uppercase font-bold px-3 py-1 rounded-full border transition-all ${selectedCategory === p ? 'bg-indigo-600 text-white' : 'bg-white text-slate-400'}`}>{p}</button>))}
                                </div>
                            </form>
                        </div>
                        <div className="flex-1 overflow-y-auto px-6 pt-4 pb-6 custom-scrollbar bg-slate-50/50">
                             <AnimatePresence>
                                {tasks.sort((a,b) => (a.completed === b.completed)? 0 : a.completed? 1 : -1).map(task => (
                                    <motion.div key={task.id} layout draggable={!task.completed} onDragStart={(e) => { e.dataTransfer.setData('taskId', task.id); }} initial={{ opacity: 0, y: 10 }} animate={{ opacity: 1, y: 0 }} className={`group flex items-center gap-3 p-3 mb-2 rounded-xl border bg-white hover:shadow-md transition-all cursor-grab active:cursor-grabbing ${task.completed ? 'opacity-50 grayscale' : 'border-slate-200 shadow-sm'}`}>
                                        <button onClick={() => setTasks(prev => prev.map(t => t.id === task.id ? {...t, completed: !t.completed} : t))} className={`w-5 h-5 rounded-full border flex items-center justify-center transition-colors ${task.completed ? 'bg-green-500 border-green-500' : 'border-slate-300 hover:border-indigo-400'}`}>{task.completed && <Check size={12} className="text-white"/>}</button>
                                        <div className="flex-1 min-w-0"><div className="text-sm font-medium truncate text-slate-700">{task.title}</div></div>
                                        <button onClick={() => openEditModal(null, null, task)} className="opacity-0 group-hover:opacity-100 p-1.5 text-slate-400 hover:text-indigo-600"><Edit2 size={14}/></button>
                                        <div className="text-slate-200"><GripVertical size={16}/></div>
                                    </motion.div>
                                ))}
                            </AnimatePresence>
                        </div>
                        <div className="p-3 bg-white border-t border-slate-200 text-xs text-slate-500 flex justify-between items-center"><span>{aiMessage}</span></div>
                    </div>
                    
                    {/* Modals */}
                    <SettingsModal isOpen={isSettingsOpen} onClose={() => setIsSettingsOpen(false)} selectedCountries={selectedCountries} onToggleCountry={handleToggleCountry} googleConnected={googleConnected} onToggleGoogle={handleToggleGoogle} googleConfig={googleConfig} onUpdateGoogleConfig={handleUpdateGoogleConfig} microsoftConnected={microsoftConnected} onToggleMicrosoft={handleToggleMicrosoft} microsoftConfig={microsoftConfig} onUpdateMicrosoftConfig={handleUpdateMicrosoftConfig} />
                    <Modal isOpen={isClockModalOpen} onClose={() => setIsClockModalOpen(false)} title="Add World Clock"><div className="grid grid-cols-1 gap-2">{TIMEZONES.map((tz, i) => (<button key={i} onClick={() => handleAddClock(tz)} className="p-3 text-left hover:bg-slate-50 rounded-lg text-sm font-medium text-slate-700 border border-transparent hover:border-slate-200">{tz.label}</button>))}</div></Modal>
                    <Modal isOpen={isEditModalOpen} onClose={() => setIsEditModalOpen(false)} title={activeItem?.id ? "Edit Details" : "New Event"}>
                        {activeItem && (
                            <div className="space-y-4">
                                <div><label className="text-xs font-bold text-slate-500 uppercase">Title</label><input type="text" value={activeItem.title} onChange={(e) => setActiveItem({...activeItem, title: e.target.value})} className="w-full mt-1 px-3 py-2 border rounded-lg outline-none focus:border-indigo-500 font-medium" autoFocus /></div>
                                {activeItem.isEvent && (
                                    <div className="bg-slate-50 p-3 rounded-xl border border-slate-100">
                                        <div className="flex items-center justify-between mb-2">
                                            <label className="text-xs font-bold text-slate-500 uppercase flex items-center gap-1"><Clock size={10}/> Schedule</label>
                                            <label className="flex items-center gap-2 text-xs cursor-pointer"><input type="checkbox" checked={activeItem.isAllDay || false} onChange={(e) => setActiveItem({...activeItem, isAllDay: e.target.checked})} className="rounded border-slate-300 text-indigo-600 focus:ring-indigo-500" /> All Day</label>
                                        </div>
                                        {!activeItem.isAllDay && (
                                            <div className="grid grid-cols-2 gap-3">
                                                <div><span className="text-[10px] text-slate-400 uppercase font-semibold">Start</span><input type="time" value={activeItem.start ? format(new Date(activeItem.start), 'HH:mm') : ''} onChange={e => { const [h, m] = e.target.value.split(':'); const d = new Date(activeItem.start); d.setHours(h,m); setActiveItem({...activeItem, start: d}); }} className="w-full mt-1 px-2 py-1.5 border rounded-md text-sm bg-white" /></div>
                                                <div><span className="text-[10px] text-slate-400 uppercase font-semibold">End</span><input type="time" value={activeItem.end ? format(new Date(activeItem.end), 'HH:mm') : ''} onChange={e => { const [h, m] = e.target.value.split(':'); const d = new Date(activeItem.end); d.setHours(h,m); setActiveItem({...activeItem, end: d}); }} className="w-full mt-1 px-2 py-1.5 border rounded-md text-sm bg-white" /></div>
                                            </div>
                                        )}
                                    </div>
                                )}
                                <div className="flex gap-3 pt-4 border-t border-slate-100"><button onClick={handleSaveItem} className="flex-1 bg-indigo-600 text-white py-2.5 rounded-xl font-bold text-sm shadow-sm hover:bg-indigo-700 transition-colors">Save Details</button><button onClick={handleDelete} className="px-4 border border-red-100 text-red-500 rounded-xl hover:bg-red-50 transition-colors"><Trash2 size={18}/></button></div>
                            </div>
                        )}
                    </Modal>
                </div>
            );
        }

        const root = createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>